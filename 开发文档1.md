***
***
这个开发文档用来记录开发过程中遇到的一些问
题，参考的一些文献，思路的点拨balabala
***
***
# 任务1：实现人脸识别的软件过程
这里我用到了下recognizer的read函数，这样可以用来读取一下我们早早训练好的白名单人员的面部特征
<br/>首先借鉴一下之前写好的人脸检测的模块（copy一下）
<br/>但是需要进行一些改编，因为初始版本仅仅完成了`识别面部->框一下`的过程,需要加上其他的一些特点，比如`predict`，将识别出来的面部用识别器(`recognizer`)对比一下，得出一个误差值(`confidence`)<br/>误差只要比我们规定的一个值小，我们就认为识别的人脸符合白名单要求
<br/>此外，我们还要在原图片中将识别出来的人脸标记上所对应的白名单上的名称，如果识别出来大于误差值，不再白名单上，我们就打一个unknown，表示识别出的人脸不符合,这里就用到了特别的函数
<br/>`cv2.putText（）`，效果是将特定的文字标注到图片上
<br/>使用范例在这篇博客里:[cv2.putText使用方法](https://blog.csdn.net/weixin_41010198/article/details/89155899)
<br/>遇到点问题，重复识别咋整，也就是无法精准识别
<br/>所以必须要有一个识别后的标准来确定一个统一的人脸图像

20：51
<br/>发现不能用return的方式来实现识别程序的终止，准备后面用usart的方式从单片机终止识别


20：53<br/>我去，对啊，应该做成一张一张的人脸识别，这样就不用担心多个人同时识别的问题了！


<br/>总之今天先解决了识别的问题了



# DAY2：
## 解决一下通信的问题：
我现在的思路是先让单片机一直向上位机发消息，直到回应为止
<br/>就先让单片机一直发"ask"，直到上位机识别吧

<br/>新知识：可以`pip install pyserial`这个包，从而可以在python上对stm32的外设进行一些操作
<br/>操作教学：[如何用python进行串口通信](https://blog.csdn.net/Beking17113/article/details/83213071)

<br/>果然不会一帆风顺，在用python进行串口通信的情况下，出现了串口无法打开的情况，我们称之为`BUG1`
<br/>报错如下:`could not open port 'COM4': PermissionError(13, '拒绝访问。', None, 5)`
<br/>查阅资料后发现，可能是占用导致的问题，在运行python的同时我还打开了其他的串口助手，从而导致了无法正常打开串口
<br/>[python串口调试的参考资料](https://blog.csdn.net/Electrical_IT/article/details/107221567)
<br/>关闭了野火的串口调试助手后，发现python可以正常的打开串口了

### 难点：如何用python实现对单片机的收发信息的控制(啊啊啊啊啊烦的一)
现在的问题是，单片机和上位机各自管各自的，根本发不到一块儿去，我测

<br/>稍微调试一下，发现好像可以操作一下，我把最初版本的那个`send string`给改成了`Send byte`首先解决了在通信过程中,*二进制通信码*和*我本来要读取的那个字符格式*因为传输原因不匹配的情况.
<br/>接下来就是让python发出一个启动信号，让单片机的LED_G点亮！
<br/>当前的问题是，python中接收的数据都是二进制的源码，需要进行一定的进制更换，比如改成十进制或者十六进制进行操作

<br/>为什么说必须进行**进制更换**，因为试了好几次，把KEIL单片机的发送的源码改了又改，发现统一都是二进制传输的十六进制的数字文件，捏麻麻地

<br/>总之我把所有python传输和接收的数据统一为了同一种模式`/x01`，还点了个灯，这样就顺利解决了启动的问题！~~原神，启动！~~
<br/>当然还是有发送信息不畅，有报错的情况出现，这个还得好好观察下才行

<br/>发现问题，如果传输的是一个string的话该如何通信呢，是个好问题

<br/>先不管了，进入下一个课题

# 将python控制通信与人脸识别联系起来
### 先训练一个我自己的人脸的特征，用到之前的那个人脸特征提取模块昂
ok，识别大概做好了，现在先让软件可以根据识别的结果来点亮灯！
<br/>做成这样，只要是识别成功了，就先熄灯，然后亮起绿灯。失败就亮红灯
# <br/>碰到了问题：无法连续接收信息
问询chatgpt我的代码编写中的问题，发现是由于未清除之前的缓冲区的信息，又马上接收下一波信息，导致无法正常接收。
```
这是修改的代码，每一次receive前都清空缓冲区

USART_ClearFlag(DEBUG_USARTx, USART_FLAG_RXNE); // 清除接收缓冲区状态位
respon = USART_ReceiveData(DEBUG_USARTx); // 接收新指令

```
结果改了还是无法解决这个问题
<br/>捏马的
我怀疑是指令区一直被占用，无法write了
重新弄一遍试试看呢
<br/>重新配置一遍中断函数咋也不好使
!!!!!!!!!
# <br/>我测，原来是python的b`\x06`不是0x06，十六进制打错来，我测

为了方便测试，必须得弄一个让单片机识别完成以后自动初始化的过程才行

# OK
大功告成
今天将人脸识别和点灯对应起来，对的人点绿灯，错的人点红灯，空闲时间点白灯，等待工作点黄灯，初始态为蓝灯

通过一些简单的延时，将识别过程和点灯结合起来力！
今天就先到这里吧，明天调试舵机，把舵机和人脸识别联系起来

# DAY3
今天进行一个PWM输出的学习捏
## 先进行简单的呼吸灯调教
分解下需要用到的知识：TIM的简单运用，PWM波的输出运用


找找教程先:<br/>
基础定时器:TIM6,TIM7(这里就贴一个教程链接就行)[基本TIM教程](https://blog.csdn.net/AriesPIG/article/details/119735744?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169216583316800225553813%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169216583316800225553813&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119735744-null-null.142^v92^chatsearchT3_1&utm_term=stm32TIM&spm=1018.2226.3001.4187)

<br/>通用定时器：TIMx
<br/>高级定时器：TIM1,TIM8


CK_PSC:提供的时钟频率<br/>
PSC:预分频数<br/>
ARR:重载周期数<br/>


需要牢记的公式！！！！！！
<br/>**PWM频率公式：**`Freq=CK_PSC/(PSC+1)/(ARR+1)`
PWM频率实际上就是电平从有效电平到无效电平再到有效电平的切换频率
<br/>**占空比公式**：`Duty=CCR/(ARR+1)`,CCR就是有效电平的百分比
<br/>**分辨率公式**：`Reso=1/(ARR+1)`

`setCompare`是一个十分重要的函数，可以帮助我们改变CCR的值，这样就可以实现呼吸灯的效果了

<br/>详情就请参见写的bsp_pwm_led文档，现在总算学（抄）完了，但是不知怎么来把野火开发板的5v开关打开，气死我了
[怎么打开5V开关](https://blog.csdn.net/NS_ice/article/details/124890926)
<br/>TNND还是不行，我服了

<br/>无奈记录下，我用ADC测试了一下VCC的那一个GPIO端口，捏麻麻地，网上说有FT管的接开漏输出，引脚就能输出5V，可是试了下结果反而变成0.3v，我服了，用推挽输出能正常3V3
<br/>心累，不知道咋解决了
<br/>我测，ADC输入的引脚电压不是FT管的，还好还好，我测，差点把ADC烧了，好险

<br/>还是没找到好的解决办法呢
<br/>会不会是pwm输出不对？没有机械转的声音，我估计电源和pwm输出都有可能有问题，我先试试做一个呼吸灯效果。


<br/>发现问题：PWM输出失败，看来得先把呼吸灯效果实现才行

<br/>哇擦，把GPIO——Init放后面了就可以正常呼吸灯，好神奇，什么原理
<br/>通过求助好哥们，好哥们说开发板的5V口子一般都是正常的，上电就能用，我明天试试看

<br/>发现问题：原来是我初始化OC口错了，应该是用OC3_Init函数

<br/>？为毛本来可以动的舵机，动了一会儿又动不了了，不会是TIM烧坏了吧我超
<br/>原来是给的参数超出范围，就停转了，改回去就好了
<br/>话说为毛我的电机一直转啊
<br/>原来是我买的是360度电机，CCR=500的时候反向转速最大，1500转速为0，2500正向转速最大，[关于舵机停不下来的问题](https://blog.csdn.net/qq_53784191/article/details/124604573?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169232323916800226513157%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169232323916800226513157&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124604573-null-null.142^v93^chatsearchT3_1&utm_term=360%E5%BA%A6%E8%88%B5%E6%9C%BA%E4%B8%80%E7%9B%B4%E8%BD%AC&spm=1018.2226.3001.4187)


<br/>接下来的思路：买个红外传感模块，初步感应有人到位，然后再买一个蜂鸣器（？），用来表示识别成功与否
<br/>要不要买个小垃圾桶来试试手呢？
<br/>先买两个舵机试试

<br/>总算到货了，在此之前我先把LCD给开动了来

# 开动LCD
NMD，怎么这么xx复杂，受不了一点
<br/>经过了两天的折磨，大概能把时序图啥的弄懂了，目前先做到能够正常使用它吧
<br/>现在只做到了调用函数实现文字，但是接下来的目标是能够在LCD上做到操作像素点和显示图像，还是任重道远的
<br/>总之先记录一下这个idea，以后慢慢学，现在先学会最基本的使用方法


### 将LCD信息和识别成功与否联系起来，可以方便辨识（待办）

# 用舵机把垃圾盖弄起来！
NMD想了半天还是直接顶起来最省事
<br/>可惜没有双面胶，明天去买点
<br/>ok,买来了，今天上午的任务就是把两个垃圾桶给驱动一下开盖程序

### 重新设置一个TIM的PWM输出口
查了一下DATAsheet，我们就采用TIM4_CH3，也就是PB8,来接入绿色垃圾桶

<br/>为了方便起见，把Delay函数解耦出来了，方便其他的模块进行调用

<br/>在进行识别的时候出现了重复识别，开盖时间与识别时间错开导致的时间混乱，所以需要调整一下识别结果传递的时间
<br/>在将LCD的各个函数与我要用到的功能函数模块化的时候碰到了一些奇怪的BUG，比如有结构体明明在头文件定义了，却还是显示未定义
<br/>查询了网上的资料，看来多半是重复定义了头文件
<br/>把LCD的几个头文件单列出来，防止重复引用，然后就可正常编译了


# 正式调整一下成果
<br/>在把LCD加入以后竟然出现了HardFault,无法在打开LCD后接着打开LED了
<br/>是通讯的超时判定导致了无法正常使用，删除即可

## <br/>下一个问题
在复位一次后竟然无法正常运转了
#### 应该是时许的问题，有延迟，delay有些乱用了
列出主要的毛病：
<br/>1.LCD刷新和接收上位机信号对不上
<br/>2.LED亮灯时间有点晚，调快点


深入一下，就是说，必须得在收发信号处做一个中断才行

<br/>在python上实现一个不断重置的FLAG位，确保是在识别后给出的结果而不是上一次识别的结果。适用于连续的识别

<br/>真是成也中断败也中断，中断导致我不能把接收的信号人为设置为RESET
<br/>从上位机入手呢？也不对啊
<br/>那为什么没有如预期一样，开关一次盖子以后停下呢
<br/>MD，怎么整，我去思考一下对中断的理解吧

# ！！果然是中断理解的问题，修改了对中断的设定以后，问题顺利解决了！
分享一下对中断的理解的文章：
<br/>[中断的理解](https://blog.csdn.net/qq_35872749/article/details/107305546?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169271895316800182756984%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=169271895316800182756984&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-107305546-null-null.142^v93^chatsearchT3_1&utm_term=STM32%20%E4%B8%AD%E6%96%AD%E6%80%8E%E4%B9%88%E8%A7%A6%E5%8F%91%E7%9A%84&spm=1018.2226.3001.4187)

# 怎么用GIT啊啊啊啊啊啊啊啊啊啊
# 没办法，只有硬学了
# 先把一些文件推送一遍试试看，建立了自己的第一个代码仓库[这里！](https://github.com/byte2rookie/test)
我测，感觉没弄懂，有点难办
<br/>目前学习顺序我想可以这样
<br/>新建一个代码仓库->学一下git的推送和提交的模板->学一下git的远程操作